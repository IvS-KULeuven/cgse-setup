{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"An intelligent navigable dictionary","text":"<p>\ud83d\udea7\u2013 WIP \u2013 this is an early version of a project in development. Please use it  and fork it and create issues and feature requests.</p> <p>This module defines the NavigableDict (aka. <code>navdict</code>), which is a dictionary that is dot-navigable and has some special features to autoload files.</p> <p>The information that is in the NavigableDict can be navigated in two different ways. First, the navdict is a dictionary, so all information can be accessed by keys as in the following example.</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({\"gse\": {\"hexapod\": {\"ID\": 42, \"calibration\": [0,1,2,3,4,5]}}})\n&gt;&gt;&gt; setup[\"gse\"][\"hexapod\"][\"ID\"]\n42\n</code></pre> <p>Second, each of the keys is also available as an attribute of the NavigableDict and that makes it possible to navigate the navdict with dot-notation:</p> <pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID\n</code></pre> <p>If you want to know which keys you can use to navigate the navdict, use the <code>keys()</code> method.</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()\ndict_keys(['ID', 'calibration'])\n&gt;&gt;&gt; setup.gse.hexapod.calibration\n[0, 1, 2, 3, 4, 5]\n</code></pre> <p>To get a full printout of the navdict, you can use the print method from the rich package. Be careful, because this can print out a lot of information when a full configuration is loaded.</p> <pre><code>&gt;&gt;&gt; from rich import print\n&gt;&gt;&gt; print(setup)\nNavigableDict\n\u2514\u2500\u2500 gse\n    \u2514\u2500\u2500 hexapod\n        \u251c\u2500\u2500 ID: 42\n        \u2514\u2500\u2500 calibration: [0, 1, 2, 3, 4, 5]\n</code></pre>"},{"location":"#special-values","title":"Special Values","text":"<p>Some of the information in the navdict is interpreted in a special way, i.e. some values are processed before returning. Examples are the classes and calibration/data files. The following values are treated special if they start with:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul>"},{"location":"#data-files","title":"Data Files","text":"<p>Some information is too large to add to the navdict as such and should be loaded from a data file. Examples are calibration files, flat-fields, temperature conversion curves, etc.</p> <p>The navdict will automatically load the file when you access a key that  contains a value that starts with <code>csv//</code> or <code>yaml//</code>.</p> <pre><code>&gt;&gt;&gt; setup = navdict({\n...     \"instrument\": {\"coeff\": \"csv//cal_coeff_1234.csv\"}\n... })\n&gt;&gt;&gt; setup.instrument.coeff[0, 4]\n5.0\n</code></pre> <p>Note: the resource location is always relative to the current location XXXX </p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow ...</p>"},{"location":"roadmap/#features","title":"Features","text":"<ul> <li> <p> the <code>csv//</code> directive might be improved with specification of the    number of rows that a header takes up, that might need to go into a field,    e.g. <code>args</code> below and at the same level as where the directive is.</p> </li> <li> <p> Add pluggable functionality to NavDict to do something like  <code>bad_pixels//&lt;filename&gt;.fits</code> and this will then execute a function that    takes the <code>&lt;filename&gt;.fits</code> as an argument. That function can return a    filename or a file descriptor, or a FITS object....</p> </li> </ul>"}]}