{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"An intelligent navigable dictionary","text":"<p>\ud83d\udea7\u2013 WIP \u2013 this is an early version of a project in development. Please use it  and fork it and create issues and feature requests.</p> <p>This module defines the NavigableDict (aka. <code>navdict</code>), which is a dictionary that is dot-navigable and has some special features to autoload files.</p> <p>The information that is in the NavigableDict can be navigated in two different ways. First, the navdict is a dictionary, so all information can be accessed by keys as in the following example.</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({\"gse\": {\"hexapod\": {\"ID\": 42, \"calibration\": [0,1,2,3,4,5]}}})\n&gt;&gt;&gt; setup[\"gse\"][\"hexapod\"][\"ID\"]\n42\n</code></pre> <p>Second, each of the keys is also available as an attribute of the NavigableDict and that makes it possible to navigate the navdict with dot-notation:</p> <pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID\n</code></pre> <p>If you want to know which keys you can use to navigate the navdict, use the <code>keys()</code> method.</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()\ndict_keys(['ID', 'calibration'])\n&gt;&gt;&gt; setup.gse.hexapod.calibration\n[0, 1, 2, 3, 4, 5]\n</code></pre> <p>To get a full printout of the navdict, you can use the print method from the rich package. Be careful, because this can print out a lot of information when a full configuration is loaded.</p> <pre><code>&gt;&gt;&gt; from rich import print\n&gt;&gt;&gt; print(setup)\nNavigableDict\n\u2514\u2500\u2500 gse\n    \u2514\u2500\u2500 hexapod\n        \u251c\u2500\u2500 ID: 42\n        \u2514\u2500\u2500 calibration: [0, 1, 2, 3, 4, 5]\n</code></pre>"},{"location":"#special-values","title":"Special Values","text":"<p>Some of the information in the navdict is interpreted in a special way, i.e. some values are processed before returning. Examples are the classes and calibration/data files. The following values are treated special if they start with:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul> <p>We call these values directives and they are explained in more detail in  How directives work.</p>"},{"location":"#data-files","title":"Data Files","text":"<p>Some information is too large to add to the navdict as such and should be loaded from a data file. Examples are calibration files, flat-fields, temperature conversion curves, etc.</p> <p>The navdict will automatically load the file when you access a key that  contains a value that starts with <code>csv//</code> or <code>yaml//</code>.</p> <pre><code>&gt;&gt;&gt; setup = navdict({\n...     \"instrument\": {\"coeff\": \"csv//cal_coeff_1234.csv\"}\n... })\n&gt;&gt;&gt; setup.instrument.coeff[0, 4]\n5.0\n</code></pre> <p>Note: the resource location is always relative to the current location XXXX </p>"},{"location":"directives/","title":"How directives work","text":""},{"location":"directives/#what-are-directives","title":"What are directives?","text":"<p>Directives are instructions in a YAML file that are interpreted by the  <code>NavigableDict</code> whenever the value containing the directive is accessed.  Let's explain this with an example. We have a simple YAML file (`setup.yaml)  with the following content:</p> <p><pre><code>Setup:\n    project_info: yaml//project_info.yaml\n</code></pre> This short YAML string contains a directive <code>yaml//</code> which will load the  <code>project_info.yaml</code> file whenever the <code>project_info</code> key is accessed. </p> <p>The <code>project_info.yaml</code> file contains the following keys:</p> <p><pre><code>project: navdict\nversion: 0.3.2\n</code></pre> Assume both YAML files are located in your HOME folder.</p> <pre><code>&gt;&gt;&gt; from navdict import NavDict\n\n&gt;&gt;&gt; setup = NavDict.from_yaml_file(\"~/setup.yaml\")\n&gt;&gt;&gt; print(setup)\nSetup:\n    project_info: yaml//project_info.yaml\n&gt;&gt;&gt; print(setup.Setup)\nproject_info: yaml//project_info.yaml\n&gt;&gt;&gt; print(setup.Setup.project_info)\nproject: navdict\nversion: 0.3.2\n</code></pre>"},{"location":"directives/#matching-directives","title":"Matching directives","text":"<p>A value containing a directive shall match against the following regular  expression:</p> <p>The value is a string matching <code>r\"^([a-zA-Z]\\w+)[\\/]{2}(.*)$\"</code> where:</p> <ul> <li>group 1 is the directive and </li> <li>group 2 is the value that is passed into the function that is associated    with the directive.</li> </ul> <p>For example, the value 'yaml//config.yaml' will match and group 1 is 'yaml'  and group 2 is 'config.yaml'.</p>"},{"location":"directives/#default-directives","title":"Default directives","text":"<p>The <code>navdict</code> project has defined the following directives:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul>"},{"location":"directives/#filenames","title":"Filenames","text":"<p>When the directive value is a filename or path, it can be absolute or  relative. An absolute filename is used as-is and passed to the directive  function. A relative filename is interpreted as follows:</p> <ul> <li>when the parent \u2014which should be a NavDict\u2014 contains a <code>_filename</code>    attribute, the value of the directive is interpreted relative to the    location of the parent.</li> <li>when the parent doesn't have a <code>_filename</code> attribute or if it is <code>None</code>,    the directive value is relative to the current working directory.</li> </ul>"},{"location":"directives/#custom-directives","title":"Custom directives","text":"<p>TBW. This section will describe how to write your own directives as a plugin.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow ...</p>"},{"location":"roadmap/#features","title":"Features","text":"<ul> <li> <p> the <code>csv//</code> directive might be improved with specification of the    number of rows that a header takes up, that might need to go into a field,    e.g. <code>args</code> below and at the same level as where the directive is.</p> </li> <li> <p> Add pluggable functionality to NavDict to do something like  <code>bad_pixels//&lt;filename&gt;.fits</code> and this will then execute a function that    takes the <code>&lt;filename&gt;.fits</code> as an argument. That function can return a    filename or a file descriptor, or a FITS object....</p> </li> </ul>"}]}